import { NativeSyntheticEvent, EmitterSubscription, ViewStyle, StyleProp } from 'react-native';

/**
 * Quartiles that can be reached during an ad playback.
 */
declare enum AdQuartile {
    FIRST = "first",
    MID_POINT = "mid_point",
    THIRD = "third"
}
/**
 * The possible types an `AdSource` can be.
 */
declare enum AdSourceType {
    IMA = "ima",
    UNKNOWN = "unknown",
    PROGRESSIVE = "progressive"
}
/**
 * Represents an ad source which can be assigned to an `AdItem`. An `AdItem` can have multiple `AdSource`s
 * as waterfalling option.
 */
interface AdSource {
    /**
     * The ad tag / url to the ad manifest.
     */
    tag: string;
    /**
     * The `AdSourceType` of this `AdSource`.
     */
    type: AdSourceType;
}
/**
 * Represents an ad break which can be scheduled for playback.
 *
 * One single `AdItem` can have multiple `AdSource`s where all but the first act as fallback ad sources
 * if the first one fails to load. The start and end of an ad break are signaled via `AdBreakStartedEvent`
 * and `AdBreakFinishedEvent`.
 */
interface AdItem {
    /**
     * The playback position at which the ad break is scheduled to start. Default value is "pre".
     *
     * Possible values are:
     *  • "pre": pre-roll ad (for VoD and Live streaming)
     *  • "post": post-roll ad (for VoD streaming only)
     *  • fractional seconds: "10", "12.5" (mid-roll ad, for VoD and Live streaming)
     *  • percentage of the entire video duration: "25%", "50%" (mid-roll ad, for VoD streaming only)
     *  • timecode hh:mm:ss.mmm: "00:10:30.000", "01:00:00.000" (mid-roll ad, for VoD streaming only)
     */
    position?: string;
    /**
     * The `AdSource`s that make up this `AdItem`. The first ad source in this array is used as the main ad.
     * Subsequent ad sources act as a fallback, meaning that if the main ad source does not provide a
     * valid response, the subsequent ad sources will be utilized one after another.
     *
     * The fallback ad sources need to have the same `AdSourceType` as the main ad source.
     */
    sources: AdSource[];
}
/**
 * Contains configuration values regarding the ads which should be played back by the player.
 */
interface AdvertisingConfig {
    /**
     * The ad items that are scheduled when a new playback session is started via `Player.load()`.
     */
    schedule: AdItem[];
}
/**
 * Contains the base configuration options for an ad.
 */
interface AdConfig {
    /**
     * Specifies how many seconds of the main video content should be replaced by ad break(s).
     */
    replaceContentDuration: number;
}
/**
 * Holds various additional ad data.
 */
interface AdData {
    /**
     * The average bitrate of the progressive media file as defined in the VAST response.
     */
    bitrate?: number;
    /**
     * The maximum bitrate of the streaming media file as defined in the VAST response.
     */
    maxBitrate?: number;
    /**
     * The MIME type of the media file or creative as defined in the VAST response.
     */
    mimeType?: string;
    /**
     * The minimum bitrate of the streaming media file as defined in the VAST response.
     */
    minBitrate?: number;
}
/**
 * Defines basic properties available for every ad type.
 */
interface Ad {
    /**
     * The url the user should be redirected to when clicking the ad.
     */
    clickThroughUrl?: string;
    /**
     * Holds various additional `AdData`.
     */
    data?: AdData;
    /**
     * The height of the ad.
     */
    height: number;
    /**
     * Identifier for the ad. This might be autogenerated.
     */
    id?: string;
    /**
     * Determines whether an ad is linear, i.e. playback of main content needs to be paused for the ad.
     */
    isLinear: boolean;
    /**
     * The corresponding media file url for the ad.
     */
    mediaFileUrl?: string;
    /**
     * The width of the ad.
     */
    width: number;
}
/**
 * Contains information about an ad break.
 */
interface AdBreak {
    /**
     * The ads scheduled for this `AdBreak`.
     */
    ads: Ad[];
    /**
     * The id of the corresponding `AdBreakConfig`. This will be auto-generated.
     */
    id: string;
    /**
     * The time in seconds in the media timeline the `AdBreak` is scheduled for.
     */
    scheduleTime: number;
}

interface NativeInstanceConfig {
    /**
     * Optionally user-defined string `id` for the native instance.
     * Used to access a certain native instance from any point in the source code then call
     * methods/properties on it.
     *
     * When left empty, a random `UUIDv4` is generated for it.
     * @example
     * Accessing or creating the `Player` with `nativeId` equal to `my-player`:
     * ```
     * const player = new Player({ nativeId: 'my-player' })
     * player.play(); // call methods and properties...
     * ```
     */
    nativeId?: string;
}
declare abstract class NativeInstance<Config extends NativeInstanceConfig> {
    /**
     * Optionally user-defined string `id` for the native instance, or UUIDv4.
     */
    readonly nativeId: string;
    /**
     * The configuration object used to initialize this instance.
     */
    readonly config?: Config;
    /**
     * Generate UUID in case the user-defined `nativeId` is empty.
     */
    constructor(config?: Config);
    /**
     * Flag indicating whether the native resources of this object have been created internally
     * .i.e `initialize` has been called.
     */
    abstract isInitialized: boolean;
    /**
     * Create the native object/resources that will be managed by this instance.
     */
    abstract initialize(): void;
    /**
     * Flag indicating whether the native resources of this object have been disposed .i.e
     * `destroy` has been called.
     */
    abstract isDestroyed: boolean;
    /**
     * Dispose the native object/resources created by this instance during `initialize`.
     */
    abstract destroy(): void;
}

/**
 * Available cdn provider options for AnalyticsConfig.
 */
declare enum CdnProvider {
    BITMOVIN = "bitmovin",
    AKAMAI = "akamai",
    FASTLY = "fastly",
    MAXCDN = "maxcdn",
    CLOUDFRONT = "cloudfront",
    CHINACACHE = "chinacache",
    BITGRAVITY = "bitgravity"
}
/**
 * Object used to configure a new `AnalyticsCollector` instance.
 */
interface AnalyticsConfig extends NativeInstanceConfig, CustomDataConfig {
    /**
     * CDN Provide that the video playback session is using.
     */
    cdnProvider?: CdnProvider;
    /**
     * User ID of the customer.
     */
    customUserId?: string;
    /**
     * Experiment name needed for A/B testing.
     */
    experimentName?: string;
    /**
     * ID of the video in the CMS system.
     */
    videoId?: string;
    /**
     * Human readable title of the video asset currently playing.
     */
    title?: string;
    /**
     * Analytics key.
     */
    key: string;
    /**
     * Player key.
     */
    playerKey?: string;
    /**
     * Breadcrumb path to show where in the app the user is.
     */
    path?: string;
    /**
     * Flag to see if stream is live before stream metadata is available (default: false).
     */
    isLive?: boolean;
    /**
     * Flag to enable Ad tracking (default: false).
     */
    ads?: boolean;
    /**
     * Flag to use randomised userId not depending on device specific values (default: false).
     */
    randomizeUserId?: boolean;
}
interface CustomDataConfig {
    /**
     * Optional free-form custom data
     */
    customData1?: string;
    /**
     * Optional free-form custom data
     */
    customData2?: string;
    /**
     * Optional free-form custom data
     */
    customData3?: string;
    /**
     * Optional free-form custom data
     */
    customData4?: string;
    /**
     * Optional free-form custom data
     */
    customData5?: string;
    /**
     * Optional free-form custom data
     */
    customData6?: string;
    /**
     * Optional free-form custom data
     */
    customData7?: string;
    /**
     * Optional free-form custom data
     */
    customData8?: string;
    /**
     * Optional free-form custom data
     */
    customData9?: string;
    /**
     * Optional free-form custom data
     */
    customData10?: string;
    /**
     * Optional free-form custom data
     */
    customData11?: string;
    /**
     * Optional free-form custom data
     */
    customData12?: string;
    /**
     * Optional free-form custom data
     */
    customData13?: string;
    /**
     * Optional free-form custom data
     */
    customData14?: string;
    /**
     * Optional free-form custom data
     */
    customData15?: string;
    /**
     * Optional free-form custom data
     */
    customData16?: string;
    /**
     * Optional free-form custom data
     */
    customData17?: string;
    /**
     * Optional free-form custom data
     */
    customData18?: string;
    /**
     * Optional free-form custom data
     */
    customData19?: string;
    /**
     * Optional free-form custom data
     */
    customData20?: string;
    /**
     * Optional free-form custom data
     */
    customData21?: string;
    /**
     * Optional free-form custom data
     */
    customData22?: string;
    /**
     * Optional free-form custom data
     */
    customData23?: string;
    /**
     * Optional free-form custom data
     */
    customData24?: string;
    /**
     * Optional free-form custom data
     */
    customData25?: string;
    /**
     * Optional free-form custom data
     */
    customData26?: string;
    /**
     * Optional free-form custom data
     */
    customData27?: string;
    /**
     * Optional free-form custom data
     */
    customData28?: string;
    /**
     * Optional free-form custom data
     */
    customData29?: string;
    /**
     * Optional free-form custom data
     */
    customData30?: string;
}

/**
 * Analytics collector that can be attached to a player object in order to collect and send
 * its analytics information.
 */
declare class AnalyticsCollector extends NativeInstance<AnalyticsConfig> {
    /**
     * Whether the native `AnalyticsCollector` object has been created.
     */
    isInitialized: boolean;
    /**
     * Whether the native `AnalyticsCollector` object has been disposed.
     */
    isDestroyed: boolean;
    /**
     * Initializes a native `BitmovinPlayerCollector` object.
     */
    initialize: () => void;
    /**
     * Disposes the native `BitmovinPlayerCollector` object that has been created
     * during initialization.
     */
    destroy: () => void;
    /**
     * Attach a player instance to this analytics plugin. After this is completed, BitmovinAnalytics
     * will start monitoring and sending analytics data based on the attached player instance.
     *
     * @param playerId - Native Id of the player to attach this collector instance.
     */
    attach: (playerId: string) => void;
    /**
     * Detach a player instance from this analytics plugin if there's any attached. If no player is attached,
     * nothing happens.
     */
    detach: () => void;
    /**
     * Dynamically updates analytics custom data information. Use this method
     * to update your custom data during runtime.
     *
     * @param customData - Analytics custom data config.
     */
    setCustomDataOnce: (customData: CustomDataConfig) => void;
    /**
     * Sets the internal analytics custom data state.
     *
     * @param customData - Analytics custom data config.
     */
    setCustomData: (customData: CustomDataConfig) => void;
    /**
     * Gets the current custom data config from the native `BitmovinPlayerCollector` instance.
     *
     * @returns The current custom data config.
     */
    getCustomData: () => Promise<CustomDataConfig>;
    /**
     * Gets the current user id used by the native `BitmovinPlayerCollector` instance.
     *
     * @returns The current user id.
     */
    getUserId: () => Promise<string>;
}

/**
 * An audio session category defines a set of audio behaviors.
 * Choose a category that most accurately describes the audio behavior you require.
 *
 * Note the `playback` category is required in order to properly enable picture in picture support.
 *
 * - `ambient`: The category for an app in which sound playback is nonprimary — that is, your app also works with the sound turned off.
 * - `multiRoute`: The category for routing distinct streams of audio data to different output devices at the same time.
 * - `playAndRecord`: The category for recording (input) and playback (output) of audio, such as for a Voice over Internet Protocol (VoIP) app.
 * - `playback`: The category for playing recorded music or other sounds that are central to the successful use of your app.
 * - `record`: The category for recording audio while also silencing playback audio.
 * - `soloAmbient`: The default audio session category.
 *
 * @platform iOS
 * @see https://developer.apple.com/documentation/avfaudio/avaudiosession/category
 */
declare type AudioSessionCategory = 'ambient' | 'multiRoute' | 'playAndRecord' | 'playback' | 'record' | 'soloAmbient';
/**
 * An object that communicates to the system how you intend to use audio in your app.
 *
 * @platform iOS
 * @see https://developer.apple.com/documentation/avfaudio/avaudiosession
 */
declare const AudioSession: {
    /**
     * Sets the audio session's category.
     *
     * @platform iOS
     * @see https://developer.apple.com/documentation/avfaudio/avaudiosession/1616583-setcategory
     */
    setCategory: (category: AudioSessionCategory) => Promise<void>;
};

/**
 * Represents an audio track for a video.
 */
interface AudioTrack {
    /**
     * The URL to the timed file, e.g. WebVTT file.
     */
    url?: string;
    /**
     * The label for this track.
     */
    label?: string;
    /**
     * The unique identifier for this track. If no value is provided, a random UUIDv4 will be generated for it.
     */
    identifier?: string;
    /**
     * If set to true, this track would be considered as default. Default is `false`.
     */
    isDefault?: boolean;
    /**
     * The IETF BCP 47 language tag associated with this track, e.g. `pt`, `en`, `es` etc.
     */
    language?: string;
}

/**
 * Utility type that maps the specified optional props from the target `Type` to be
 * required props. Note all the other props stay unaffected.
 *
 * @example
 * type MyType = {
 *   a?: string;
 *   b?: number;
 *   c?: boolean;
 * };
 *
 * type MyRequiredType = MakeRequired<MyType, 'a' | 'c'> // => { a: string; b?: number; c: boolean; }
 */
declare type MakeRequired<Type, Key extends keyof Type> = Omit<Type, Key> & Required<Pick<Type, Key>>;

/**
 * Supported subtitle/caption file formats.
 */
declare enum SubtitleFormat {
    CEA = "cea",
    TTML = "ttml",
    VTT = "vtt"
}
/**
 * Represents a custom subtitle track source that can be added to `SourceConfig.subtitleTracks`.
 */
interface SubtitleTrack {
    /**
     * The URL to the timed file, e.g. WebVTT file.
     */
    url?: string;
    /**
     * The label for this track.
     */
    label?: string;
    /**
     * The unique identifier for this track. If no value is provided, a random UUIDv4 will be generated for it.
     */
    identifier?: string;
    /**
     * Specifies the file format to be used by this track.
     */
    format?: SubtitleFormat;
    /**
     * If set to true, this track would be considered as default. Default is `false`.
     */
    isDefault?: boolean;
    /**
     * Tells if a subtitle track is forced. If set to `true` it means that the player should automatically
     * select and switch this subtitle according to the selected audio language. Forced subtitles do
     * not appear in `Player.getAvailableSubtitles`.
     *
     * Default is `false`.
     */
    isForced?: boolean;
    /**
     * The IETF BCP 47 language tag associated with this track, e.g. `pt`, `en`, `es` etc.
     */
    language?: string;
}
/**
 * Helper type that represents an entry in `SourceConfig.subtitleTracks` list.
 *
 * Since `SubtitleTrack` has all of its properties as optionals for total compatibility with
 * values that may be sent from native code, this type serves as a reinforcer of what properties
 * should be required during the registration of an external subtitle track from JS.
 */
declare type SideLoadedSubtitleTrack = MakeRequired<SubtitleTrack, 'url' | 'label' | 'language' | 'format'>;

/**
 * Quality definition of a video representation.
 */
interface VideoQuality {
    /**
     * The id of the media quality.
     */
    id: string;
    /**
     * The label of the media quality that should be exposed to the user.
     */
    label?: string;
    /**
     * The bitrate of the media quality.
     */
    bitrate?: number;
    /**
     * The codec of the media quality.
     */
    codec?: string;
    /**
     * The frame rate of the video quality. If the frame rate is not known or not applicable a value of -1 will be returned.
     */
    frameRate?: number;
    /**
     * The height of the video quality.
     */
    height?: number;
    /**
     * The width of the video quality.
     */
    width?: number;
}

/**
 * Base event type for all events.
 */
interface Event {
    /**
     * This event name as it is on the native side.
     */
    name: string;
    /**
     * The UNIX timestamp in which this event happened.
     */
    timestamp: number;
}
/**
 * Base event type for error and warning events.
 */
interface ErrorEvent extends Event {
    /**
     * Error/Warning's code number.
     */
    code?: number;
    /**
     * Error/Warning's localized message.
     */
    message: string;
    /**
     * Underlying data emitted with the Error/Warning.
     */
    data?: Record<string, any>;
}
/**
 * Emitted when a source is loaded into the player.
 * Seeking and time shifting are allowed as soon as this event is seen.
 */
interface PlayerActiveEvent extends Event {
}
/**
 * Emitted when a player error happens.
 */
interface PlayerErrorEvent extends ErrorEvent {
}
/**
 * Emitted when a player warning happens.
 */
interface PlayerWarningEvent extends ErrorEvent {
}
/**
 * Emitted when the player is destroyed.
 */
interface DestroyEvent extends Event {
}
/**
 * Emitted when the player is muted.
 */
interface MutedEvent extends Event {
}
/**
 * Emitted when the player is unmuted.
 */
interface UnmutedEvent extends Event {
}
/**
 * Emitted when the player is ready for immediate playback, because initial audio/video
 * has been downloaded.
 */
interface ReadyEvent extends Event {
}
/**
 * Emitted when the player is paused.
 */
interface PausedEvent extends Event {
    /**
     * The player's playback time from when this event happened.
     */
    time: number;
}
/**
 * Emitted when the player received an intention to start/resume playback.
 */
interface PlayEvent extends Event {
    /**
     * The player's playback time from when this event happened.
     */
    time: number;
}
/**
 * Emitted when playback has started.
 */
interface PlayingEvent extends Event {
    /**
     * The player's playback time from when this event happened.
     */
    time: number;
}
/**
 * Emitted when the playback of the current media has finished.
 */
interface PlaybackFinishedEvent extends Event {
}
/**
 * Source object representation the way it appears on `Event` payloads such as `SeekEvent`, for example.
 *
 * This interface only type hints what should be the shape of a `Source` object inside an `Event`'s
 * payload during runtime so it has no direct relation with the `Source` class present in `src/source.ts`.
 *
 * Do not mistake it for a `NativeInstance` type.
 */
interface EventSource {
    /**
     * Event's source duration in seconds.
     */
    duration: number;
    /**
     * Whether this event's source is currently active in a player.
     */
    isActive: boolean;
    /**
     * Whether this event's source is currently attached to a player instance.
     */
    isAttachedToPlayer: boolean;
    /**
     * Metadata for this event's source.
     */
    metadata?: Record<string, any>;
}
/**
 * Emitted when the player is about to seek to a new position.
 * Only applies to VoD streams.
 */
interface SeekEvent extends Event {
    /**
     * Removed source metadata.
     */
    from: {
        time: number;
        source: EventSource;
    };
    /**
     * Added source metadata.
     */
    to: {
        time: number;
        source: EventSource;
    };
}
/**
 * Emitted when seeking has finished and data to continue playback is available.
 * Only applies to VoD streams.
 */
interface SeekedEvent extends Event {
}
/**
 * Emitted when the player starts time shifting.
 * Only applies to live streams.
 */
interface TimeShiftEvent extends Event {
    /**
     * The position from which we start the time shift
     */
    position: number;
    /**
     * The position to which we want to jump for the time shift
     */
    targetPosition: number;
}
/**
 * Emitted when time shifting has finished and data is available to continue playback.
 * Only applies to live streams.
 */
interface TimeShiftedEvent extends Event {
}
/**
 * Emitted when the player begins to stall and to buffer due to an empty buffer.
 */
interface StallStartedEvent extends Event {
}
/**
 * Emitted when the player ends stalling, due to enough data in the buffer.
 */
interface StallEndedEvent extends Event {
}
/**
 * Emitted when the current playback time has changed.
 */
interface TimeChangedEvent extends Event {
    /**
     * The player's playback time from when this event happened.
     */
    currentTime: number;
}
/**
 * Emitted when a new source loading has started.
 * It doesn't mean that the loading of the new manifest has finished.
 */
interface SourceLoadEvent extends Event {
    /**
     * Source that is about to load.
     */
    source: EventSource;
}
/**
 * Emitted when a new source is loaded.
 * It doesn't mean that the loading of the new manifest has finished.
 */
interface SourceLoadedEvent extends Event {
    /**
     * Source that was loaded into player.
     */
    source: EventSource;
}
/**
 * Emitted when the current source has been unloaded.
 */
interface SourceUnloadedEvent extends Event {
    /**
     * Source that was unloaded from player.
     */
    source: EventSource;
}
/**
 * Emitted when a source error happens.
 */
interface SourceErrorEvent extends ErrorEvent {
}
/**
 * Emitted when a source warning happens.
 */
interface SourceWarningEvent extends ErrorEvent {
}
/**
 * Emitted when a new audio track is added to the player.
 */
interface AudioAddedEvent extends Event {
    /**
     * Audio track that has been added.
     */
    audioTrack: AudioTrack;
}
/**
 * Emitted when the player's selected audio track has changed.
 */
interface AudioChangedEvent extends Event {
    /**
     * Audio track that was previously selected.
     */
    oldAudioTrack: AudioTrack;
    /**
     * Audio track that is selected now.
     */
    newAudioTrack: AudioTrack;
}
/**
 * Emitted when an audio track is removed from the player.
 */
interface AudioRemovedEvent extends Event {
    /**
     * Audio track that has been removed.
     */
    audioTrack: AudioTrack;
}
/**
 * Emitted when a new subtitle track is added to the player.
 */
interface SubtitleAddedEvent extends Event {
    /**
     * Subtitle track that has been added.
     */
    subtitleTrack: SubtitleTrack;
}
/**
 * Emitted when a subtitle track is removed from the player.
 */
interface SubtitleRemovedEvent extends Event {
    /**
     * Subtitle track that has been removed.
     */
    subtitleTrack: SubtitleTrack;
}
/**
 * Emitted when the player's selected subtitle track has changed.
 */
interface SubtitleChangedEvent extends Event {
    /**
     * Subtitle track that was previously selected.
     */
    oldSubtitleTrack: SubtitleTrack;
    /**
     * Subtitle track that is selected now.
     */
    newSubtitleTrack: SubtitleTrack;
}
interface VideoSizeChangedEvent extends Event {
    height?: number;
    width?: number;
    aspectRatio?: number;
}
interface DurationChangedEvent extends Event {
    duration: number;
}
/**
 * Emitted when the player enters Picture in Picture mode.
 *
 * @platform iOS, Android
 */
interface PictureInPictureEnterEvent extends Event {
}
/**
 * Emitted when the player exits Picture in Picture mode.
 *
 * @platform iOS, Android
 */
interface PictureInPictureExitEvent extends Event {
}
/**
 * Emitted when the player has finished entering Picture in Picture mode on iOS.
 *
 * @platform iOS
 */
interface PictureInPictureEnteredEvent extends Event {
}
/**
 * Emitted when the player has finished exiting Picture in Picture mode on iOS.
 *
 * @platform iOS
 */
interface PictureInPictureExitedEvent extends Event {
}
/**
 * Emitted when the fullscreen functionality has been enabled.
 *
 * @platform iOS, Android
 */
interface FullscreenEnabledEvent extends Event {
}
/**
 * Emitted when the fullscreen functionality has been disabled.
 *
 * @platform iOS, Android
 */
interface FullscreenDisabledEvent extends Event {
}
/**
 * Emitted when the player enters fullscreen mode.
 *
 * @platform iOS, Android
 */
interface FullscreenEnterEvent extends Event {
}
/**
 * Emitted when the player exits fullscreen mode.
 *
 * @platform iOS, Android
 */
interface FullscreenExitEvent extends Event {
}
/**
 * Emitted when the availability of the Picture in Picture mode changed on Android.
 *
 * @platform Android
 */
interface PictureInPictureAvailabilityChangedEvent extends Event {
    /**
     * Whether Picture in Picture is available.
     */
    isPictureInPictureAvailable: boolean;
}
/**
 * Emitted when an ad break has started.
 */
interface AdBreakStartedEvent extends Event {
    /**
     * The `AdBreak` that has started.
     */
    adBreak?: AdBreak;
}
/**
 * Emitted when an ad break has finished.
 */
interface AdBreakFinishedEvent extends Event {
    /**
     * The `AdBreak` that has finished.
     */
    adBreak?: AdBreak;
}
/**
 * Emitted when the playback of an ad has started.
 */
interface AdStartedEvent extends Event {
    /**
     * The `Ad` this event is related to.
     */
    ad?: Ad;
    /**
     * The target URL to open once the user clicks on the ad.
     */
    clickThroughUrl?: string;
    /**
     * The `AdSourceType` of the started `Ad`.
     */
    clientType?: AdSourceType;
    /**
     * The duration of the ad in seconds.
     */
    duration: number;
    /**
     * The index of the ad in the queue.
     */
    indexInQueue: number;
    /**
     * The position of the corresponding `Ad`.
     */
    position?: string;
    /**
     * The skip offset of the ad in seconds.
     */
    skipOffset: number;
    /**
     * The content time at which the `Ad` is played.
     */
    timeOffset: number;
}
/**
 * Emitted when an ad has finished playback.
 */
interface AdFinishedEvent extends Event {
    /**
     * The `Ad` that finished playback.
     */
    ad?: Ad;
}
/**
 * Emitted when an error with the ad playback occurs.
 */
interface AdErrorEvent extends ErrorEvent {
    /**
     * The `AdConfig` for which the ad error occurred.
     */
    adConfig?: AdConfig;
    /**
     * The `AdItem` for which the ad error occurred.
     */
    adItem?: AdItem;
}
/**
 * Emitted when an ad was clicked.
 */
interface AdClickedEvent extends Event {
    /**
     * The click through url of the ad.
     */
    clickThroughUrl?: string;
}
/**
 * Emitted when an ad was skipped.
 */
interface AdSkippedEvent extends Event {
    /**
     * The `Ad` that was skipped.
     */
    ad?: Ad;
}
/**
 * Emitted when the playback of an ad has progressed over a quartile boundary.
 */
interface AdQuartileEvent extends Event {
    /**
     * The `AdQuartile` boundary that playback has progressed over.
     */
    quartile: AdQuartile;
}
/**
 * Emitted when an ad manifest was successfully downloaded, parsed and added into the ad break schedule.
 */
interface AdScheduledEvent extends Event {
    /**
     * The total number of scheduled ads.
     */
    numberOfAds: number;
}
/**
 * Emitted when the download of an ad manifest is started.
 */
interface AdManifestLoadEvent extends Event {
    /**
     * The `AdBreak` this event is related to.
     */
    adBreak?: AdBreak;
    /**
     * The `AdConfig` of the loaded ad manifest.
     */
    adConfig?: AdConfig;
}
/**
 * Emitted when an ad manifest was successfully loaded.
 */
interface AdManifestLoadedEvent extends Event {
    /**
     * The `AdBreak` this event is related to.
     */
    adBreak?: AdBreak;
    /**
     * The `AdConfig` of the loaded ad manifest.
     */
    adConfig?: AdConfig;
    /**
     * How long it took for the ad tag to be downloaded in milliseconds.
     */
    downloadTime: number;
}
/**
 * Emitted when the current video playback quality has changed.
 */
interface VideoPlaybackQualityChangedEvent extends Event {
    /**
     * The new quality
     */
    newVideoQuality: VideoQuality;
    /**
     * The previous quality
     */
    oldVideoQuality: VideoQuality;
}

/**
 * Type that defines all event props supported by `PlayerView` and `NativePlayerView`.
 * Used to generate the specific events interface for each component.
 */
interface EventProps {
    onAdBreakFinished: AdBreakFinishedEvent;
    onAdBreakStarted: AdBreakStartedEvent;
    onAdClicked: AdClickedEvent;
    onAdError: AdErrorEvent;
    onAdFinished: AdFinishedEvent;
    onAdManifestLoad: AdManifestLoadEvent;
    onAdManifestLoaded: AdManifestLoadedEvent;
    onAdQuartile: AdQuartileEvent;
    onAdScheduled: AdScheduledEvent;
    onAdSkipped: AdSkippedEvent;
    onAdStarted: AdStartedEvent;
    onDestroy: DestroyEvent;
    onEvent: Event;
    onFullscreenEnabled: FullscreenEnabledEvent;
    onFullscreenDisabled: FullscreenDisabledEvent;
    onFullscreenEnter: FullscreenEnterEvent;
    onFullscreenExit: FullscreenExitEvent;
    onMuted: MutedEvent;
    onPaused: PausedEvent;
    onPictureInPictureAvailabilityChanged: PictureInPictureAvailabilityChangedEvent;
    onPictureInPictureEnter: PictureInPictureEnterEvent;
    onPictureInPictureEntered: PictureInPictureEnteredEvent;
    onPictureInPictureExit: PictureInPictureExitEvent;
    onPictureInPictureExited: PictureInPictureExitedEvent;
    onPlay: PlayEvent;
    onPlaybackFinished: PlaybackFinishedEvent;
    onPlayerActive: PlayerActiveEvent;
    onPlayerError: PlayerErrorEvent;
    onPlayerWarning: PlayerWarningEvent;
    onPlaying: PlayingEvent;
    onReady: ReadyEvent;
    onSeek: SeekEvent;
    onSeeked: SeekedEvent;
    onTimeShift: TimeShiftEvent;
    onTimeShifted: TimeShiftedEvent;
    onStallStarted: StallStartedEvent;
    onStallEnded: StallEndedEvent;
    onSourceError: SourceErrorEvent;
    onSourceLoad: SourceLoadEvent;
    onSourceLoaded: SourceLoadedEvent;
    onSourceUnloaded: SourceUnloadedEvent;
    onSourceWarning: SourceWarningEvent;
    onAudioAdded: AudioAddedEvent;
    onAudioChanged: AudioChangedEvent;
    onAudioRemoved: AudioRemovedEvent;
    onSubtitleAdded: SubtitleAddedEvent;
    onSubtitleChanged: SubtitleChangedEvent;
    onSubtitleRemoved: SubtitleRemovedEvent;
    onTimeChanged: TimeChangedEvent;
    onUnmuted: UnmutedEvent;
    onVideoSizeChanged: VideoSizeChangedEvent;
    onDurationChanged: DurationChangedEvent;
    onVideoPlaybackQualityChanged: VideoPlaybackQualityChangedEvent;
}
/**
 * Event props for `PlayerView`.
 *
 * Note the events of `PlayerView` are simply a proxy over
 * the events from `NativePlayerView` just removing RN's bubbling data.
 */
declare type PlayerViewEvents = {
    [Prop in keyof EventProps]?: (event: EventProps[Prop]) => void;
};
/**
 * Event props for `NativePlayerView`.
 */
declare type NativePlayerViewEvents = {
    [Prop in keyof EventProps]?: (nativeEvent: NativeSyntheticEvent<EventProps[Prop]>) => void;
};

/**
 * Represents a FairPlay Streaming DRM config.
 */
interface FairplayConfig {
    /**
     * The DRM license acquisition URL.
     */
    licenseUrl: string;
    /**
     * The URL to the FairPlay Streaming certificate of the license server.
     */
    certificateUrl?: string;
    /**
     * A dictionary to specify custom HTTP headers for the license request.
     */
    licenseRequestHeaders?: Record<string, string>;
    /**
     * A dictionary to specify custom HTTP headers for the certificate request.
     */
    certificateRequestHeaders?: Record<string, string>;
    /**
     * A block to prepare the loaded certificate before building SPC data and passing it into the
     * system. This is needed if the server responds with anything else than the certificate, e.g. if
     * the certificate is wrapped into a JSON object. The server response for the certificate request
     * is passed as parameter “as is”.
     *
     * Note that both the passed `certificate` data and this block return value should be a Base64
     * string. So use whatever solution suits you best to handle Base64 in React Native.
     *
     * @param certificate - Base64 encoded certificate data.
     * @returns The processed Base64 encoded certificate.
     */
    prepareCertificate?: (certificate: string) => string;
    /**
     * A block to prepare the data which is sent as the body of the POST license request.
     * As many DRM providers expect different, vendor-specific messages, this can be done using
     * this user-defined block.
     *
     * Note that both the passed `message` data and this block return value should be a Base64 string.
     * So use whatever solution suits you best to handle Base64 in React Native.
     *
     * @param message - Base64 encoded message data.
     * @param assetId - Stream asset ID.
     * @returns The processed Base64 encoded message.
     */
    prepareMessage?: (message: string, assetId: string) => string;
    /**
     * A block to prepare the data which is sent as the body of the POST request for syncing the DRM
     * license information.
     *
     * Note that both the passed `syncMessage` data and this block return value should be a Base64
     * string. So use whatever solution suits you best to handle Base64 in React Native.
     *
     * @param message - Base64 encoded message data.
     * @param assetId - Asset ID.
     * @returns The processed Base64 encoded sync message.
     */
    prepareSyncMessage?: (syncMessage: string, assetId: string) => string;
    /**
     * A block to prepare the loaded CKC Data before passing it to the system. This is needed if the
     * server responds with anything else than the license, e.g. if the license is wrapped into a JSON
     * object.
     *
     * Note that both the passed `license` data and this block return value should be a Base64 string.
     * So use whatever solution suits you best to handle Base64 in React Native.
     *
     * @param license - Base64 encoded license data.
     * @returns The processed Base64 encoded license.
     */
    prepareLicense?: (license: string) => string;
    /**
     * A block to prepare the URI (without the skd://) from the HLS manifest before passing it to the
     * system.
     *
     * @param licenseServerUrl - License server URL string.
     * @returns The processed license server URL string.
     */
    prepareLicenseServerUrl?: (licenseServerUrl: string) => string;
    /**
     * A block to prepare the `contentId`, which is sent to the FairPlay Streaming license server as
     * request body, and which is used to build the SPC data. As many DRM providers expect different,
     * vendor-specific messages, this can be done using this user-defined block. The parameter is the
     * skd:// URI extracted from the HLS manifest (m3u8) and the return value should be the contentID
     * as string.
     *
     * @param contentId - Extracted content id string.
     * @returns The processed contentId.
     */
    prepareContentId?: (contentId: string) => string;
}

/**
 * Represents a Widevine Streaming DRM config.
 * Android only.
 */
interface WidevineConfig {
    /**
     * The DRM license acquisition URL.
     */
    licenseUrl: string;
    /**
     * A map containing the HTTP request headers, or null.
     */
    httpHeaders: Record<string, string>;
    /**
     * A block to prepare the data which is sent as the body of the POST license request.
     * As many DRM providers expect different, vendor-specific messages, this can be done using
     * this user-defined block.
     *
     * Note that both the passed `message` data and this block return value should be a Base64 string.
     * So use whatever solution suits you best to handle Base64 in React Native.
     *
     * @param message - Base64 encoded message data.
     * @returns The processed Base64 encoded message.
     */
    prepareMessage?: (message: string) => string;
    /**
     * A block to prepare the loaded CKC Data before passing it to the system. This is needed if the
     * server responds with anything else than the license, e.g. if the license is wrapped into a JSON
     * object.
     *
     * Note that both the passed `license` data and this block return value should be a Base64 string.
     * So use whatever solution suits you best to handle Base64 in React Native.
     *
     * @param license - Base64 encoded license data.
     * @returns The processed Base64 encoded license.
     */
    prepareLicense?: (license: string) => string;
    /**
     * Set widevine's preferred security level.
     */
    preferredSecurityLevel?: string;
    /**
     * Indicates if the DRM sessions should be kept alive after a source is unloaded.
     * This allows DRM sessions to be reused over several different source items with the same DRM configuration as well
     * as the same DRM scheme information.
     * Default: `false`
     */
    shouldKeepDrmSessionsAlive: boolean;
}

/**
 * Represents the general Streaming DRM config.
 */
interface DrmConfig extends NativeInstanceConfig {
    /**
     * FairPlay specific configuration. Only applicable for iOS.
     */
    fairplay?: FairplayConfig;
    /**
     * Widevine specific configuration. Only applicable for Android.
     */
    widevine?: WidevineConfig;
}
/**
 * Represents a native DRM configuration object.
 */
declare class Drm extends NativeInstance<DrmConfig> {
    /**
     * Whether this object's native instance has been created.
     */
    isInitialized: boolean;
    /**
     * Whether this object's native instance has been disposed.
     */
    isDestroyed: boolean;
    /**
     * Allocates the DRM config instance and its resources natively.
     */
    initialize: () => void;
    /**
     * Destroys the native DRM config and releases all of its allocated resources.
     */
    destroy: () => void;
    /**
     * iOS only.
     *
     * Applies the user-defined `prepareCertificate` function to native's `certificate` data and store
     * the result back in `DrmModule`.
     *
     * Called from native code when `FairplayConfig.prepareCertificate` is dispatched.
     *
     * @param certificate - Base64 encoded certificate data.
     */
    onPrepareCertificate: (certificate: string) => void;
    /**
     * Applies the user-defined `prepareMessage` function to native's `message` data and store
     * the result back in `DrmModule`.
     *
     * Called from native code when `prepareMessage` is dispatched.
     *
     * @param message - Base64 encoded message data.
     * @param assetId - Optional asset ID. Only sent by iOS.
     */
    onPrepareMessage: (message: string, assetId?: string) => void;
    /**
     * iOS only.
     *
     * Applies the user-defined `prepareSyncMessage` function to native's `syncMessage` data and
     * store the result back in `DrmModule`.
     *
     * Called from native code when `FairplayConfig.prepareSyncMessage` is dispatched.
     *
     * @param syncMessage - Base64 encoded sync SPC message data.
     */
    onPrepareSyncMessage: (syncMessage: string, assetId: string) => void;
    /**
     * Applies the user-defined `prepareLicense` function to native's `license` data and store
     * the result back in `DrmModule`.
     *
     * Called from native code when `prepareLicense` is dispatched.
     *
     * @param license - Base64 encoded license data.
     */
    onPrepareLicense: (license: string) => void;
    /**
     * iOS only.
     *
     * Applies the user-defined `prepareLicenseServerUrl` function to native's `licenseServerUrl` data
     * and store the result back in `DrmModule`.
     *
     * Called from native code when `FairplayConfig.prepareLicenseServerUrl` is dispatched.
     *
     * @param licenseServerUrl - The license server URL string.
     */
    onPrepareLicenseServerUrl: (licenseServerUrl: string) => void;
    /**
     * iOS only.
     *
     * Applies the user-defined `prepareContentId` function to native's `contentId` string
     * and store the result back in `DrmModule`.
     *
     * Called from native code when `FairplayConfig.prepareContentId` is dispatched.
     *
     * @param contentId - The extracted contentId string.
     */
    onPrepareContentId: (contentId: string) => void;
}

/**
 * Types of media that can be handled by the player.
 */
declare enum SourceType {
    /**
     * Indicates a missing source type.
     */
    NONE = "none",
    /**
     * Indicates media type HLS.
     */
    HLS = "hls",
    /**
     * Indicates media type DASH.
     */
    DASH = "dash",
    /**
     * Indicates media type Progressive MP4.
     */
    PROGRESSIVE = "progressive"
}
/**
 * The different loading states a `Source` instance can be in.
 */
declare enum LoadingState {
    /**
     * The source is unloaded.
     */
    UNLOADED = 0,
    /**
     * The source is currently loading.
     */
    LOADING = 1,
    /**
     * The source is loaded.
     */
    LOADED = 2
}
/**
 * Represents a source configuration that be loaded into a player instance.
 */
interface SourceConfig extends NativeInstanceConfig {
    /**
     *  The url for this source configuration.
     */
    url: string;
    /**
     * The `SourceType` for this configuration.
     */
    type?: SourceType;
    /**
     * The title of the video source.
     */
    title?: string;
    /**
     * The URL to a preview image displayed until the video starts.
     */
    poster?: string;
    /**
     * Indicates whether to show the poster image during playback.
     * Useful, for example, for audio-only streams.
     */
    isPosterPersistent?: boolean;
    /**
     * The DRM config for the source.
     */
    drmConfig?: DrmConfig;
    /**
     * External subtitle tracks to be added into the player.
     */
    subtitleTracks?: SideLoadedSubtitleTrack[];
    /**
     * External thumbnails to be added into the player.
     */
    thumbnailTrack?: string;
    /**
     * The optional custom metadata. Also sent to the cast receiver when loading the Source.
     */
    metadata?: Record<string, string>;
}
/**
 * Represents audio and video content that can be loaded into a player.
 */
declare class Source extends NativeInstance<SourceConfig> {
    /**
     * The native DRM config reference of this source.
     */
    drm?: Drm;
    /**
     * Whether the native `Source` object has been created.
     */
    isInitialized: boolean;
    /**
     * Whether the native `Source` object has been disposed.
     */
    isDestroyed: boolean;
    /**
     * Allocates the native `Source` instance and its resources natively.
     */
    initialize: () => void;
    /**
     * Destroys the native `Source` and releases all of its allocated resources.
     */
    destroy: () => void;
    /**
     * The duration of the source in seconds if it’s a VoD or `INFINITY` if it’s a live stream.
     * Default value is `0` if the duration is not available or not known.
     */
    duration: () => Promise<number>;
    /**
     * Whether the source is currently active in a player (i.e. playing back or paused).
     * Only one source can be active in the same player instance at any time.
     */
    isActive: () => Promise<boolean>;
    /**
     * Whether the source is currently attached to a player instance.
     */
    isAttachedToPlayer: () => Promise<boolean>;
    /**
     * Metadata for the currently loaded source.
     */
    metadata: () => Promise<Record<string, any> | null>;
    /**
     * Set metadata for the currently loaded source.
     * Setting the metadata to `null` clears the metadata object in native source.
     */
    setMetadata: (metadata: Record<string, any> | null) => void;
    /**
     * The current `LoadingState` of the source.
     */
    loadingState: () => Promise<LoadingState>;
}

/**
 * Contains config values which can be used to alter the visual presentation and behaviour of the player UI.
 */
interface StyleConfig {
    /**
     * Sets if the UI should be enabled or not. Default value is true.
     * @example
     * ```
     * const player = new Player({
     *   styleConfig: {
     *     isUiEnabled: false,
     *   },
     * });
     * ```
     */
    isUiEnabled?: boolean;
    /**
     * iOS/tvOS only.
     *
     * Set which user interface type should be used.
     * Default value is UserInterfaceType.bitmovin on iOS and UserInterfaceType.system on tvOS.
     * This setting only applies if StyleConfig#isUiEnabled is set to true.
     * @example
     * ```
     * const player = new Player({
     *   styleConfig: {
     *     isUiEnabled: false,
     *     userInterfaceType: UserInterfaceType.subtitle,
     *   },
     * });
     * ```
     */
    userInterfaceType?: UserInterfaceType;
    /**
     * Set the CSS file that will be used for the UI. The default CSS file will be completely replaced by the CSS file set with this property.
     * @example
     * ```
     * const player = new Player({
     *   styleConfig: {
     *     playerUiCss: 'https://domain.tld/path/to/bitmovinplayer-ui.css',
     *   },
     * });
     * ```
     * @platform iOS, Android
     */
    playerUiCss?: string;
    /**
     * Set a CSS file which contains supplemental styles for the player UI. These styles will be added to the default CSS file or the CSS file set with StyleConfig#playerUiCss.
     * @example
     * ```
     * const player = new Player({
     *   styleConfig: {
     *     supplementalPlayerUiCss: 'https://domain.tld/path/to/bitmovinplayer-supplemental-ui.css',
     *   },
     * });
     * ```
     * @platform iOS, Android
     */
    supplementalPlayerUiCss?: string;
    /**
     * Sets the JS file that will be used for the UI. The default JS file will be completely replaced by the JS file set with this property.
     * @example
     * ```
     * const player = new Player({
     *   styleConfig: {
     *     playerUiJs: 'https://domain.tld/path/to/bitmovinplayer-ui.js',
     *   },
     * });
     * ```
     * @platform iOS, Android
     */
    playerUiJs?: string;
    /**
     * Determines how the video content is scaled or stretched within the parent container’s bounds.  Possible values are defined in ScalingMode.
     * Default value is ScalingMode.fit.
     * @example
     * ```
     * const player = new Player({
     *   styleConfig: {
     *     scalingMode: ScalingMode.Zoom,
     *   },
     * });
     * ```
     */
    scalingMode?: ScalingMode;
}
/**
 * Indicates which type of UI should be used.
 */
declare enum UserInterfaceType {
    /**
     * Indicates that Bitmovin’s customizable UI should be used.
     */
    bitmovin = "bitmovin",
    /**
     * Indicates that the system UI should be used.
     */
    system = "system",
    /**
     * Indicates that only subtitles should be displayed along with the video content
     */
    subtitle = "subtitle"
}
/**
 * Specifies how the video content is scaled or stretched.
 */
declare enum ScalingMode {
    /**
     * Specifies that the player should preserve the video’s aspect ratio and fit the video within the container's bounds.
     */
    Fit = "Fit",
    /**
     * Specifies that the video should be stretched to fill the container’s bounds. The aspect ratio may not be preserved.
     */
    Stretch = "Stretch",
    /**
     * Specifies that the player should preserve the video’s aspect ratio and fill the container’s bounds.
     */
    Zoom = "Zoom"
}

/**
 * This configuration is used as an incubator for experimental features. Tweaks are not officially
 * supported and are not guaranteed to be stable, i.e. their naming, functionality and API can
 * change at any time within the tweaks or when being promoted to an official feature and moved
 * into its final configuration namespace.
 */
interface TweaksConfig {
    /**
     * The frequency in seconds onTimeChanged is called with TimeChangedEvents.
     *
     * Default value in iOS is `1.0`.
     * Default value in Android is `0.2`.
     *
     * @platform iOS, Android
     */
    timeChangedInterval?: number;
    /**
     * If enabled, HLS playlists will be parsed and additional features and events are enabled. This includes:
     *
     * - MetadataEvents carrying segment-specific metadata for custom HLS tags, like #EXT-X-SCTE35
     * - MetadataParsedEvents carrying segment-specific metadata for custom HLS tags, like #EXT-X-SCTE35
     * - DrmDataParsedEvents when a #EXT-X-KEY is found
     * - Player.availableVideoQualities includes additional information
     * - Automatic retries when HLS playlist requests failed with non-2xx HTTP status code
     *
     * Default is false.
     *
     * @platform iOS
     */
    isNativeHlsParsingEnabled?: boolean;
    /**
     * If enabled, playlists will be downloaded by the Bitmovin Player SDK instead of AVFoundation.
     * This enables additional features and events, like:
     *
     * - DownloadFinishedEvents for playlist downloads.
     * - SourceWarningEvents when no #EXT-X-PLAYLIST-TYPE is found If set to false, enabling
     * nativeHlsParsingEnabled won’t have any effect.
     *
     * Default is true.
     *
     * @platform iOS
     */
    isCustomHlsLoadingEnabled?: boolean;
    /**
     * The threshold which will be applied when seeking to the end in seconds. This value will be used
     * to calculate the maximum seekable time when calling player.seek(time:) or player.playlist.seek(source:time:),
     * so the maximum value will be duration - seekToEndThreshold.
     *
     * This is useful if the duration of the segments does not match the duration specified in the
     * manifest. In this case, if we try to seek to the end, AVPlayer could get stuck and might stall
     * forever Therefore increasing this value could help.
     *
     * Default is 0.5.
     *
     * @platform iOS
     */
    seekToEndThreshold?: number;
    /**
     * Specifies the player behaviour when Player.play is called. Default is 'relaxed'.
     *
     * - 'relaxed': Starts playback when enough media data is buffered and continuous playback without stalling can be ensured. If insufficient media data is buffered for playback to start, the player will act as if the buffer became empty during playback.
     * - 'aggressive': When the buffer is not empty, this setting will cause the player to start playback of available media immediately. If insufficient media data is buffered for playback to start, the player will act as if the buffer became empty during playback.
     *
     * @platform iOS
     */
    playbackStartBehaviour?: 'relaxed' | 'aggressive';
    /**
     * Specifies the player behaviour when stalling should be exited. Default is 'relaxed'.
     *
     * - 'relaxed': The player will wait until the buffer is filled that it can, most likely, ensure continuous playback without another stalling right after playback continued.
     * - 'aggressive': The player will try to unstall as soon as some media data became available and will start playback of this media immediately.
     *
     * @platform iOS
     */
    unstallingBehaviour?: 'relaxed' | 'aggressive';
    /**
     * Constantly aggregated and weighted bandwidth samples are summed up to this weight limit to calculate an bandwidth estimation. Remaining samples (i.e. that would lead to exceeding the limit) are dropped from memory as they are not relevant anymore.
     * Default is 2000.
     *
     * @platform Android
     */
    bandwidthEstimateWeightLimit?: number;
    /**
     * Some devices have an incorrect implementation of MediaCodec.setOutputSurface. This leads to failure when the surface changes. To prevent failure, the codec will be released and re-instantiated in those scenarios.
     *
     * @platform Android
     */
    devicesThatRequireSurfaceWorkaround?: {
        /**
         * A device name as reported by Build.DEVICE.
         *
         * @see Build.DEVICE: https://developer.android.com/reference/kotlin/android/os/Build.html#DEVICE--
         */
        deviceNames?: string[];
        /**
         * A model name as reported by Build.MODEL.
         *
         * @see Build.MODEL: https://developer.android.com/reference/kotlin/android/os/Build.html#MODEL--
         */
        modelNames?: string[];
    };
    /**
     * Specifies if the language property on DASH Representations, HLS Renditions and SmoothStreaming QualityLevels is normalized.
     * If enabled, language properties are normalized to IETF BCP 47 language tags. Default is true.
     *
     * Examples:
     * - "ENG" is normalized to "en"
     * - "en_us" is normalized to "en-us"
     * - "en-US-x-lvariant-POSIX" is normalized to "en-us-posix"
     *
     * @platform Android
     */
    languagePropertyNormalization?: boolean;
    /**
     * The interval in which dynamic DASH windows are updated locally. I.e. The rate by which the
     * playback window is moved forward on the timeline.
     *
     * @platform Android
     */
    localDynamicDashWindowUpdateInterval?: number;
    /**
     * Specifies whether default positioning values should be assumed when parsing TTML regions in case of
     * unsupported TTML features. Default is true
     *
     * @platform Android
     */
    shouldApplyTtmlRegionWorkaround?: boolean;
    /**
     * Specifies whether a DRM session should be used for clear tracks of type video and audio. Using
     * DRM sessions for clear content avoids the recreation of decoders when transitioning between clear
     * and encrypted sections of content. Default is false.
     *
     * @platform Android
     */
    useDrmSessionForClearPeriods?: boolean;
    /**
     * Specifies whether a DRM session should be used for clear tracks of type video and audio in a clear
     * source that follows after a DRM protected source. In addition, a DRM session will be used for clear
     * periods in a DRM protected source. Using DRM sessions for clear content avoids the recreation of
     * decoders when transitioning between clear and encrypted sections of content. Default is false.
     *
     * @platform Android
     */
    useDrmSessionForClearSources?: boolean;
    /**
     * Specifies if the player should always fall back to an extractor matching the file type, if no
     * matching extractor was found. If the fallback is applied, this will ignore potential incompatibilities
     * with streams and thus can result in unstable or failing playback.
     *
     * @platform Android
     */
    useFiletypeExtractorFallbackForHls?: boolean;
}

/**
 * Object used to configure a new `OfflineContentManager` instance.
 */
interface OfflineContentConfig extends NativeInstanceConfig {
    /**
     * An identifier for this source that is unique within the location and must never change.
     * The root folder will contain a folder based on this id.
     */
    identifier: string;
    /**
     * The `SourceConfig` used to download the offline resources.
     */
    sourceConfig: SourceConfig;
}
/**
 * Object used configure how the native offline managers create and get offline source configurations
 * iOS Only
 */
interface OfflineSourceOptions {
    /**
     * Whether or not the player should restrict playback only to audio, video and subtitle tracks which are stored offline on the device. This has to be set to true if the device has no network access.
     */
    restrictedToAssetCache?: boolean;
}
/**
 * Contains the states an OfflineOptionEntry can have.
 */
declare enum OfflineOptionEntryState {
    /**
     * The `OfflineOptionEntry` is downloaded and ready for offline playback.
     */
    Downloaded = "Downloaded",
    /**
     * The `OfflineOptionEntry` is currently downloading.
     */
    Downloading = "Downloading",
    /**
     * The download of the `OfflineOptionEntry` is suspended, and is only partly downloaded yet.
     */
    Suspended = "Suspended",
    /**
     * The `OfflineOptionEntry` is not downloaded. However, some data may be still cached.
     */
    NotDownloaded = "NotDownloaded"
}
/**
 * Superclass of entries which can be selected to download for offline playback
 */
interface OfflineOptionEntry {
    /**
     * The ID of the option.
     */
    id: string;
    /**
     * The language of the option.
     */
    language?: string;
}
/**
 * Represents the information from the `OfflineContentManagerListener` that is available to download
 */
interface OfflineContentOptions {
    /**
     * Represents the audio options available for download
     */
    audioOptions: OfflineOptionEntry[];
    /**
     * Represents the text options available for download
     */
    textOptions: OfflineOptionEntry[];
}
interface OfflineDownloadRequest {
    minimumBitrate: number;
    audioOptionIds: string[];
    textOptionIds: string[];
}
/**
 * Contains information about a DRM license.
 */
interface DrmLicenseInformation {
    /**
     * The remaining license duration.
     */
    licenseDuration: number;
    /**
     * The remaining playback duration.
     */
    playbackDuration: number;
}

/**
 * Enum to hold the `eventType` on the `BitmovinNativeOfflineEventData`
 */
declare enum OfflineEventType {
    onCompleted = "onCompleted",
    onError = "onError",
    onProgress = "onProgress",
    onOptionsAvailable = "onOptionsAvailable",
    onDrmLicenseUpdated = "onDrmLicenseUpdated",
    onDrmLicenseExpired = "onDrmLicenseExpired",
    onSuspended = "onSuspended",
    onResumed = "onResumed",
    onCanceled = "onCanceled"
}
interface OfflineEvent<T extends OfflineEventType> {
    /**
     * The native id associated with the `OfflineContentManager` emitting this event
     */
    nativeId: string;
    /**
     * The supplied id representing the source associated with the `OfflineContentManager` emitting this event.
     */
    identifier: string;
    /**
     * The `OfflineEventType` that correlates to which native `OfflineContentManagerListener` method was called.
     */
    eventType: T;
}
/**
 * BitmovinOfflineEvent for when the download process has completed.
 */
interface OnCompletedEvent extends OfflineEvent<OfflineEventType.onCompleted> {
    /**
     * The options that are available to download
     */
    options?: OfflineContentOptions;
    /**
     * The current offline download state
     */
    state: OfflineOptionEntryState;
}
/**
 * BitmovinOfflineEvent for when an error has occurred.
 */
interface OnErrorEvent extends OfflineEvent<OfflineEventType.onError> {
    /**
     * The error code of the process error
     */
    code?: number;
    /**
     * The error message of the process error
     */
    message?: string;
}
/**
 * BitmovinOfflineEvent for when there is a progress change for the process call.
 */
interface OnProgressEvent extends OfflineEvent<OfflineEventType.onProgress> {
    /**
     * The progress for the current process
     */
    progress: number;
}
/**
 * BitmovinOfflineEvent for when the `OfflineContentOptions` is available after a `OfflineContentManager.getOptions` call.
 */
interface OnOptionsAvailableEvent extends OfflineEvent<OfflineEventType.onOptionsAvailable> {
    /**
     * The options that are available to download
     */
    options?: OfflineContentOptions;
    /**
     * The current offline download state
     */
    state: OfflineOptionEntryState;
}
/**
 * BitmovinOfflineEvent for when the DRM license was updated.
 */
interface OnDrmLicenseUpdatedEvent extends OfflineEvent<OfflineEventType.onDrmLicenseUpdated> {
}
/**
 * BitmovinOfflineEvent for when the DRM license has expired.
 * (iOS only)
 */
interface OnDrmLicenseExpiredEvent extends OfflineEvent<OfflineEventType.onDrmLicenseExpired> {
}
/**
 * BitmovinOfflineEvent for when all active actions have been suspended.
 */
interface OnSuspendedEvent extends OfflineEvent<OfflineEventType.onSuspended> {
}
/**
 * BitmovinOfflineEvent for when all actions have been resumed.
 */
interface OnResumedEvent extends OfflineEvent<OfflineEventType.onResumed> {
}
/**
 * BitmovinOfflineEvent for when the download of the media content was cancelled by the user and all partially downloaded content has been deleted from disk.
 * (iOS only)
 */
interface OnCanceledEvent extends OfflineEvent<OfflineEventType.onCanceled> {
}
/**
 * The type aggregation for all possible native offline events received from the `DeviceEventEmitter`
 */
declare type BitmovinNativeOfflineEventData = OnCompletedEvent | OnOptionsAvailableEvent | OnProgressEvent | OnErrorEvent | OnDrmLicenseUpdatedEvent | OnDrmLicenseExpiredEvent | OnSuspendedEvent | OnResumedEvent | OnCanceledEvent;
/**
 * The listener that can be passed to the `OfflineContentManager` to receive callbacks for different events.
 */
interface OfflineContentManagerListener {
    onCompleted?: (e: OnCompletedEvent) => void;
    onError?: (e: OnErrorEvent) => void;
    onProgress?: (e: OnProgressEvent) => void;
    onOptionsAvailable?: (e: OnOptionsAvailableEvent) => void;
    onDrmLicenseUpdated?: (e: OnDrmLicenseUpdatedEvent) => void;
    onDrmLicenseExpired?: (e: OnDrmLicenseExpiredEvent) => void;
    onSuspended?: (e: OnSuspendedEvent) => void;
    onResumed?: (e: OnResumedEvent) => void;
    onCanceled?: (e: OnCanceledEvent) => void;
}
declare const handleBitmovinNativeOfflineEvent: (data: BitmovinNativeOfflineEventData, listeners: Set<OfflineContentManagerListener>) => void;

/**
 * Provides the means to download and store sources locally that can be played back with a Player
 * without an active network connection.  An OfflineContentManager instance can be created via
 * the constructor and will be idle until initialized.
 */
declare class OfflineContentManager extends NativeInstance<OfflineContentConfig> {
    isInitialized: boolean;
    isDestroyed: boolean;
    eventSubscription?: EmitterSubscription;
    listeners: Set<OfflineContentManagerListener>;
    constructor(config: OfflineContentConfig);
    /**
     * Allocates the native `OfflineManager` instance and its resources natively.
     * Registers the `DeviceEventEmitter` listener to receive data from the native `OfflineContentManagerListener` callbacks
     */
    initialize: () => Promise<void>;
    /**
     * Adds a listener to the receive data from the native `OfflineContentManagerListener` callbacks
     * Returns a function that removes this listener from the `OfflineContentManager` that registered it.
     */
    addListener: (listener: OfflineContentManagerListener) => (() => void);
    /**
     * Destroys the native `OfflineManager` and releases all of its allocated resources.
     */
    destroy: () => Promise<void>;
    /**
     * Gets the current offline source config of the `OfflineContentManager`
     */
    getOfflineSourceConfig: (options?: OfflineSourceOptions) => Promise<SourceConfig>;
    /**
     * Loads the current `OfflineContentOptions`.
     * When the options are loaded the data will be passed to the `OfflineContentManagerListener.onOptionsAvailable`.
     */
    getOptions: () => Promise<void>;
    /**
     * Enqueues downloads according to the `OfflineDownloadRequest`.
     * The promise will reject in the event of null or invalid request parameters.
     * The promise will reject when selecting an `OfflineOptionEntry` to download that is not compatible with the current state.
     * The promise will resolve when the download has been queued.  The download will is not finished when the promise resolves.
     */
    process: (request: OfflineDownloadRequest) => Promise<void>;
    /**
     * Resumes all suspended actions.
     */
    resume: () => Promise<void>;
    /**
     * Suspends all active actions.
     */
    suspend: () => Promise<void>;
    /**
     * Cancels and deletes the active download.
     */
    cancelDownload: () => Promise<void>;
    /**
     * Resolves how many bytes of storage are used by the offline content.
     */
    usedStorage: () => Promise<number>;
    /**
     * Deletes everything related to the related content ID.
     */
    deleteAll: () => Promise<void>;
    /**
     * Resolves A `DrmLicenseInformation` object containing the remaining drm license duration and the remaining playback duration.
     * The promise will reject if the loading of the DRM key fails.
     * The promise will reject if the provided DRM technology is not supported.
     * The promise will reject if the DRM licensing call to the server fails.
     */
    offlineDrmLicenseInformation: () => Promise<DrmLicenseInformation>;
    /**
     * Downloads the offline license.
     * When finished successfully data will be passed to the `OfflineContentManagerListener.onDrmLicenseUpdated`.
     * Errors are transmitted to the `OfflineContentManagerListener.onError`.
     */
    downloadLicense: () => Promise<void>;
    /**
     * Releases the currently held offline license.
     * When finished successfully data will be passed to the `OfflineContentManagerListener.onDrmLicenseUpdated`.
     * Errors are transmitted to the `OfflineContentManagerListener.onError`.
     */
    releaseLicense: () => Promise<void>;
    /**
     * Renews the already downloaded DRM license.
     * When finished successfully data will be passed to the `OfflineContentManagerListener.onDrmLicenseUpdated`.
     * Errors are transmitted to the `OfflineContentManagerListener.onError`.
     */
    renewOfflineLicense: () => Promise<void>;
    static disposeAll: () => Promise<void>;
}

/**
 * Object used to configure a new `Player` instance.
 */
interface PlayerConfig extends NativeInstanceConfig {
    /**
     * Bitmovin license key that can be found in the Bitmovin portal.
     * If a license key is set here, it will be used instead of the license key found in the `Info.plist` and `AndroidManifest.xml`.
     * @example
     * Configuring the player license key from source code:
     * ```
     * const player = new Player({
     *   licenseKey: '\<LICENSE-KEY-CODE\>',
     * });
     * ```
     * @example
     * `licenseKey` can be safely omitted from source code if it has
     * been configured in Info.plist/AndroidManifest.xml.
     * ```
     * const player = new Player(); // omit `licenseKey`
     * player.play(); // call methods and properties...
     * ```
     */
    licenseKey?: string;
    /**
     * Configures playback behaviour. A default PlaybackConfig is set initially.
     */
    playbackConfig?: PlaybackConfig;
    /**
     * Configures the visual presentation and behaviour of the player UI. A default StyleConfig is set initially.
     */
    styleConfig?: StyleConfig;
    /**
     * Configures advertising functionality. A default AdvertisingConfig is set initially.
     */
    advertisingConfig?: AdvertisingConfig;
    /**
     * Configures experimental features. A default TweaksConfig is set initially.
     */
    tweaksConfig?: TweaksConfig;
    /**
     * Configures analytics functionality.
     */
    analyticsConfig?: AnalyticsConfig;
}
/**
 * Configures the playback behaviour of the player.
 */
interface PlaybackConfig {
    /**
     * Whether the player starts playing automatically after loading a source or not. Default is `false`.
     * @example
     * ```
     * const player = new Player({
     *   playbackConfig: {
     *     isAutoplayEnabled: true,
     *   },
     * });
     * ```
     */
    isAutoplayEnabled?: boolean;
    /**
     * Whether the sound is muted on startup or not. Default value is `false`.
     * @example
     * ```
     * const player = new Player({
     *   playbackConfig: {
     *     isMuted: true,
     *   },
     * });
     * ```
     */
    isMuted?: boolean;
    /**
     * Whether time shift / DVR for live streams is enabled or not. Default is `true`.
     *  @example
     * ```
     * const player = new Player({
     *   playbackConfig: {
     *     isTimeShiftEnabled: false,
     *   },
     * });
     * ```
     */
    isTimeShiftEnabled?: boolean;
    /**
     * Whether background playback is enabled or not.
     * Default is `false`.
     *
     * When set to `true`, playback is not automatically paused
     * anymore when the app moves to the background.
     * When set to `true`, also make sure to properly configure your app to allow
     * background playback.
     *
     * On tvOS, background playback is only supported for audio-only content.
     *
     * Default is `false`.
     *
     *  @example
     * ```
     * const player = new Player({
     *   {
     *     isBackgroundPlaybackEnabled: true,
     *   }
     * })
     * ```
     */
    isBackgroundPlaybackEnabled?: boolean;
    /**
     * Whether the Picture in Picture mode option is enabled or not. Default is `false`.
     *  @example
     * ```
     * const player = new Player({
     *   playbackConfig: {
     *     isPictureInPictureEnabled: true,
     *   },
     * });
     * ```
     */
    isPictureInPictureEnabled?: boolean;
}
/**
 * Loads, controls and renders audio and video content represented through `Source`s. A player
 * instance can be created via the `usePlayer` hook and will idle until one or more `Source`s are
 * loaded. Once `load` is called, the player becomes active and initiates necessary downloads to
 * start playback of the loaded source(s).
 *
 * Can be attached to `PlayerView` component in order to use Bitmovin's Player Web UI.
 * @see PlayerView
 */
declare class Player extends NativeInstance<PlayerConfig> {
    /**
     * Currently active source, or `null` if none is active.
     */
    source?: Source;
    /**
     * Analytics collector currently attached to this player instance.
     */
    analyticsCollector?: AnalyticsCollector;
    /**
     * Whether the native `Player` object has been created.
     */
    isInitialized: boolean;
    /**
     * Whether the native `Player` object has been disposed.
     */
    isDestroyed: boolean;
    /**
     * Allocates the native `Player` instance and its resources natively.
     */
    initialize: () => void;
    /**
     * Destroys the native `Player` and releases all of its allocated resources.
     */
    destroy: () => void;
    /**
     * Loads a new `Source` from `sourceConfig` into the player.
     */
    load: (sourceConfig: SourceConfig) => void;
    /**
     * Loads the OfflineSourceConfig into the player.
     */
    loadOfflineSource: (offlineContentManager: OfflineContentManager, options?: OfflineSourceOptions) => void;
    /**
     * Loads the given `Source` into the player.
     */
    loadSource: (source: Source) => void;
    /**
     * Unloads all `Source`s from the player.
     */
    unload: () => void;
    /**
     * Starts or resumes playback after being paused. Has no effect if the player is already playing.
     */
    play: () => void;
    /**
     * Pauses the video if it is playing. Has no effect if the player is already paused.
     */
    pause: () => void;
    /**
     * Seeks to the given playback time specified by the parameter `time` in seconds. Must not be
     * greater than the total duration of the video. Has no effect when watching a live stream since
     * seeking is not possible.
     *
     * @param time - The time to seek to in seconds.
     */
    seek: (time: number) => void;
    /**
     * Shifts the time to the given `offset` in seconds from the live edge. The resulting offset has to be within the
     * timeShift window as specified by `maxTimeShift` (which is a negative value) and 0. When the provided `offset` is
     * positive, it will be interpreted as a UNIX timestamp in seconds and converted to fit into the timeShift window.
     * When the provided `offset` is negative, but lower than `maxTimeShift`, then it will be clamped to `maxTimeShift`.
     * Has no effect for VoD.
     *
     * Has no effect if no sources are loaded.
     */
    timeShift: (offset: number) => void;
    /**
     * Mutes the player if an audio track is available. Has no effect if the player is already muted.
     */
    mute: () => void;
    /**
     * Unmutes the player if it is muted. Has no effect if the player is already unmuted.
     */
    unmute: () => void;
    /**
     * Sets the player's volume between 0 (silent) and 100 (max volume).
     *
     * @param volume - The volume level to set.
     */
    setVolume: (volume: number) => void;
    /**
     * @returns The player's current volume level.
     */
    getVolume: () => Promise<number>;
    /**
     * The playback speed of the player. Slow motion can be achieved by setting the speed to values between 0 and 1,
     * while fast forward is possible with values greater than 1. Values that are less than or equal to zero are ignored.
     *
     * @param speed - The playback speed of the player.
     */
    setPlaybackSpeed: (speed: number) => void;
    /**
     * @returns The player's current playback speed.
     */
    getPlaybackSpeed: () => Promise<number>;
    /**
     * @returns The current playback time in seconds.
     *
     * For VoD streams the returned time ranges between 0 and the duration of the asset.
     *
     * For live streams it can be specified if an absolute UNIX timestamp or a value
     * relative to the playback start should be returned.
     *
     * @param mode - The time mode to specify: an absolute UNIX timestamp ('absolute') or relative time ('relative').
     */
    getCurrentTime: (mode?: 'relative' | 'absolute') => Promise<number>;
    /**
     * @returns The total duration in seconds of the current video or INFINITY if it’s a live stream.
     */
    getDuration: () => Promise<number>;
    /**
     * @returns `true` if the player is muted.
     */
    isMuted: () => Promise<boolean>;
    /**
     * @returns `true` if the player is currently playing, i.e. has started and is not paused.
     */
    isPlaying: () => Promise<boolean>;
    /**
     * @returns `true` if the player has started playback but it's currently paused.
     */
    isPaused: () => Promise<boolean>;
    /**
     * @returns `true` if the displayed video is a live stream.
     */
    isLive: () => Promise<boolean>;
    /**
     * @remarks Only available for iOS devices.
     * @returns `true` when media is played externally using AirPlay.
     */
    isAirPlayActive: () => Promise<boolean>;
    /**
     * @remarks Only available for iOS devices.
     * @returns `true` when AirPlay is available.
     */
    isAirPlayAvailable: () => Promise<boolean>;
    /**
     * @returns An array containing AudioTrack objects for all available audio tracks.
     */
    getAvailableAudioTracks: () => Promise<AudioTrack[]>;
    /**
     * Sets the audio track to the ID specified by trackIdentifier. A list can be retrieved by calling getAvailableAudioTracks.
     */
    setAudioTrack: (trackIdentifier: string) => Promise<void>;
    /**
     * @returns An array containing SubtitleTrack objects for all available subtitle tracks.
     */
    getAvailableSubtitles: () => Promise<SubtitleTrack[]>;
    /**
     * Sets the subtitle track to the ID specified by trackIdentifier. A list can be retrieved by calling getAvailableSubtitles.
     */
    setSubtitleTrack: (trackIdentifier?: string) => Promise<void>;
    /**
     * Dynamically schedules the `adItem` for playback.
     * Has no effect if there is no active playback session.
     *
     * @param adItem - Ad to be scheduled for playback.
     *
     * @platform iOS, Android
     */
    scheduleAd: (adItem: AdItem) => void;
    /**
     * Skips the current ad.
     * Has no effect if the current ad is not skippable or if no ad is being played back.
     *
     * @platform iOS, Android
     */
    skipAd: () => Promise<void>;
    /**
     * @returns `true` while an ad is being played back or when main content playback has been paused for ad playback.
     * @platform iOS, Android
     */
    isAd: () => Promise<boolean>;
    /**
     * The current time shift of the live stream in seconds. This value is always 0 if the active `source` is not a
     * live stream or no sources are loaded.
     */
    getTimeShift: () => Promise<number>;
    /**
     * The limit in seconds for time shifting. This value is either negative or 0 and it is always 0 if the active
     * `source` is not a live stream or no sources are loaded.
     */
    getMaxTimeShift: () => Promise<number>;
    static disposeAll: () => Promise<null>;
}

/**
 * Handles the UI state change when fullscreen should be entered or exited.
 */
interface FullscreenHandler {
    /**
     * Indicates if the UI is currently in fullscreen mode
     */
    isFullscreenActive: boolean;
    /**
     * Is called by the `PlayerView` when the UI should enter fullscreen mode.
     */
    enterFullscreen(): void;
    /**
     * Is called by the `PlayerView` when the UI should exit fullscreen mode.
     */
    exitFullscreen(): void;
}

interface CustomMessageSender {
    sendMessage(message: string, data: string | undefined): void;
}

/**
 * Android and iOS only.
 * For Android it requires Player SDK version 3.39.0 or higher.
 *
 * Provides a two-way communication channel between the Player UI and the integration.
 */
declare class CustomMessageHandler {
    private readonly onReceivedSynchronousMessage;
    private readonly onReceivedAsynchronousMessage;
    customMessageSender?: CustomMessageSender;
    /**
     * Android and iOS only.
     *
     * Creates a new `CustomMessageHandler` instance to handle two-way communication between the integation and the Player UI.
     *
     * @param onReceivedSynchronousMessage - A function that will be called when the Player UI sends a synchronous message to the integration.
     * @param onReceivedAsynchronousMessage - A function that will be called when the Player UI sends an asynchronous message to the integration.
     */
    constructor({ onReceivedSynchronousMessage, onReceivedAsynchronousMessage, }: {
        onReceivedSynchronousMessage: (message: string, data: string | undefined) => string | undefined;
        onReceivedAsynchronousMessage: (message: string, data: string | undefined) => void;
    });
    receivedSynchronousMessage(message: string, data: string | undefined): string | undefined;
    receivedAsynchronousMessage(message: string, data: string | undefined): void;
    /**
     * Android and iOS only.
     *
     * Sends a message to the Player UI.
     *
     * @param message - Identifier for the callback which should be called.
     * @param data - Payload for the callback.
     */
    sendMessage(message: string, data: string | undefined): void;
}

/**
 * Base `PlayerView` component props. Used to stablish common
 * props between `NativePlayerView` and `PlayerView`.
 * @see NativePlayerView
 */
interface BasePlayerViewProps {
    style?: ViewStyle;
    disableAdUi?: boolean;
}
/**
 * `PlayerView` component props.
 * @see PlayerView
 */
interface PlayerViewProps extends BasePlayerViewProps, PlayerViewEvents {
    /**
     * `Player` instance (generally returned from `usePlayer` hook) that will control
     * and render audio/video inside the `PlayerView`.
     */
    player: Player;
    fullscreenHandler?: FullscreenHandler;
    customMessageHandler?: CustomMessageHandler;
}
/**
 * Component that provides the Bitmovin Player UI and default UI handling to an attached `Player` instance.
 * This component needs a `Player` instance to work properly so make sure one is passed to it as a prop.
 */
declare function PlayerView({ style, player, fullscreenHandler, customMessageHandler, ...props }: PlayerViewProps): JSX.Element;

declare type TypefaceFamily = 'DEFAULT' | 'MONOSPACE' | 'SANS_SERIF' | 'SERIF';
declare type TypefaceStyleWeight = 'NORMAL' | 'BOLD' | 'BOLD_ITALIC' | 'ITALIC';
/**
 * Base `SubtitleView` component props. Used to establish common
 * props between `NativeSubtitleView` and `SubtitleView`.
 * @see NativePlayerView
 */
interface BaseSubtitleViewProps {
    style?: StyleProp<ViewStyle>;
    /**
     * Sets whether font sizes embedded within the cues should be applied.
     * Enabled by default.
     * Only takes effect if setApplyEmbeddedStyles is set to true.
     */
    applyEmbeddedFontSizes?: boolean;
    /**
     * Sets the caption style to be equivalent to the one returned by getUserStyle, or to a default style before API level 19.
     */
    userDefaultStyle?: boolean;
    /**
     * Sets the text size to one derived from getFontScale, or to a default size before API level 19.
     */
    userDefaultTextSize?: boolean;
    /**
     * Sets whether styling embedded within the cues should be applied.
     * Enabled by default.
     * Overrides any setting made with setApplyEmbeddedFontSizes.
     */
    applyEmbeddedStyles?: boolean;
    /**
     * Sets the bottom padding fraction to apply when getLine is DIMEN_UNSET, as a fraction of the view's remaining height after its top and bottom padding have been subtracted.
     */
    bottomPaddingFraction?: number;
    /**
     * Set the text size to a given unit and value.
     * `unit` defaults to `COMPLEX_UNIT_SP`
     */
    fixedTextSize?: {
        size: number;
        unit?: 'COMPLEX_UNIT_PX' | 'COMPLEX_UNIT_DIP' | 'COMPLEX_UNIT_SP' | 'COMPLEX_UNIT_PT' | 'COMPLEX_UNIT_IN' | 'COMPLEX_UNIT_MM';
    };
    /**
     * Sets the text size to be a fraction of the height of this view.
     * When `ignorePadding` is true, sets the text size to be a fraction of the views remaining height after its top and bottom padding have been subtracted.
     */
    fractionalTextSize?: {
        fractionOfHeight: number;
        ignorePadding?: boolean;
    };
    /**
     * Sets the subtitles caption style.
     */
    captionStyle?: {
        foregroundColor?: string;
        backgroundColor?: string;
        windowColor?: string;
        edgeType?: 'EDGE_TYPE_NONE' | 'EDGE_TYPE_OUTLINE' | 'EDGE_TYPE_DROP_SHADOW' | 'EDGE_TYPE_RAISED' | 'EDGE_TYPE_DEPRESSED';
        edgeColor?: string;
        typeFace?: {
            family: TypefaceFamily;
            style: TypefaceStyleWeight;
        } | {
            familyName: string;
            style: TypefaceStyleWeight;
        };
    };
}
/**
 * `SubtitleView` component props.
 * @see SubtitleView
 */
interface SubtitleViewProps extends BaseSubtitleViewProps {
    /**
     * `Player` instance (generally returned from `usePlayer` hook) that will control
     * and render audio/video inside the `PlayerView`.
     */
    player?: Player;
}
/**
 * Component that provides the Bitmovin Android SubtitleView for a `Player` instance.
 * This component needs a `Player` instance to work properly so make sure one is passed to it as a prop.
 */
declare function SubtitleView(props: SubtitleViewProps): JSX.Element | null;

/**
 * React hook that creates and returns a reference to a `Player` instance
 * that can be used inside any component.
 */
declare function usePlayer(config?: PlayerConfig): Player;

export { Ad, AdBreak, AdBreakFinishedEvent, AdBreakStartedEvent, AdClickedEvent, AdConfig, AdData, AdErrorEvent, AdFinishedEvent, AdItem, AdManifestLoadEvent, AdManifestLoadedEvent, AdQuartile, AdQuartileEvent, AdScheduledEvent, AdSkippedEvent, AdSource, AdSourceType, AdStartedEvent, AdvertisingConfig, AnalyticsCollector, AnalyticsConfig, AudioAddedEvent, AudioChangedEvent, AudioRemovedEvent, AudioSession, AudioSessionCategory, AudioTrack, BasePlayerViewProps, BaseSubtitleViewProps, BitmovinNativeOfflineEventData, CdnProvider, CustomDataConfig, CustomMessageHandler, DestroyEvent, Drm, DrmConfig, DrmLicenseInformation, DurationChangedEvent, ErrorEvent, Event, EventSource, FairplayConfig, FullscreenDisabledEvent, FullscreenEnabledEvent, FullscreenEnterEvent, FullscreenExitEvent, FullscreenHandler, LoadingState, MutedEvent, NativePlayerViewEvents, OfflineContentConfig, OfflineContentManager, OfflineContentManagerListener, OfflineContentOptions, OfflineDownloadRequest, OfflineEvent, OfflineEventType, OfflineOptionEntry, OfflineOptionEntryState, OfflineSourceOptions, OnCanceledEvent, OnCompletedEvent, OnDrmLicenseExpiredEvent, OnDrmLicenseUpdatedEvent, OnErrorEvent, OnOptionsAvailableEvent, OnProgressEvent, OnResumedEvent, OnSuspendedEvent, PausedEvent, PictureInPictureAvailabilityChangedEvent, PictureInPictureEnterEvent, PictureInPictureEnteredEvent, PictureInPictureExitEvent, PictureInPictureExitedEvent, PlayEvent, PlaybackConfig, PlaybackFinishedEvent, Player, PlayerActiveEvent, PlayerConfig, PlayerErrorEvent, PlayerView, PlayerViewEvents, PlayerViewProps, PlayerWarningEvent, PlayingEvent, ReadyEvent, ScalingMode, SeekEvent, SeekedEvent, SideLoadedSubtitleTrack, Source, SourceConfig, SourceErrorEvent, SourceLoadEvent, SourceLoadedEvent, SourceType, SourceUnloadedEvent, SourceWarningEvent, StallEndedEvent, StallStartedEvent, StyleConfig, SubtitleAddedEvent, SubtitleChangedEvent, SubtitleFormat, SubtitleRemovedEvent, SubtitleTrack, SubtitleView, SubtitleViewProps, TimeChangedEvent, TimeShiftEvent, TimeShiftedEvent, TypefaceFamily, TypefaceStyleWeight, UnmutedEvent, UserInterfaceType, VideoPlaybackQualityChangedEvent, VideoSizeChangedEvent, WidevineConfig, handleBitmovinNativeOfflineEvent, usePlayer };
